Python3
Flask
PostgreSQL
psycopg2: connect to Postgres server to a Flask application 
SQLAlchemy
Flask-SQLAlchemy

Database Management System
  Software to interact with a database

Database Application Programming Interfaces (DBAPIs)
  Interact with a database from another language/webserver framework

pyscopg2
  library to interact with database from Python

relational databases
  database: collection of data
  database system: storing/retrieving data 

properties of databases
  Persistence: access later 
  Shared source of truth: accessible by many usuers
  Store many data types 
  Concurrency control (handling many db actions at once)

relational vs nonrelational databases 
  
relational database 
  All data is stored in tables
  Every list of columns with data types per column
  Data intergrity: 
    Constraints 
    Triggers

Primary Keys (Composite key for multiple columns of primary keys)
  1 or more columns that uniquely identifies the whole row
  If more than 1 column

Foreign Key
  Maps 2 primary keys: encodes relationship from one table to another 

    Ex vehicles, drivers 
    id of drivers 
    have driver_id in anaother table's columns to link drivers and v    vehicles 

SQL: Structure Query Language
  Standard langage for communicating with a relational database 

  Different "dialects" 

SQL commands 
  Manipulating data
    Insert 
    Update
    Delete

  Querying data
    Select

  Structure data
    Create table
    Alter table
    Drop table

    Add column
    Drop column

Client Server model
  Request/Response 

Server: Postgres
Client: Command line applications/Graphical User Interfaces/Web apps

Database Server -[Web Server - Web Client]

Database - Server - Client 

Client - Server - Database 

Communication protocols used to transfer data over internet 

TCP/IP: Transmission Control Protocol / Internet Protocol 

Client/Server uses a communication protocol 

Postgres follows client-server model and supports TCP/IP for communication 


IP addresses: location of computers on a network 
Ports: describes where to receive traffic at recipient computer 

port 80: HTTP requests 
5432: most database ports - Default port for Postgres

TCP/IP: 
  connection-based protocol
  Open a connection to start communications 
  Close a connection to end communications 

TCP/IP suit of protocols

connections/sessions 

session: marks the start and end of a connection

session: 
start a connection - transactions are committed to the database- end a connection

UDP: User Datagram Protocol
  Hosts on the network send data (datagrams) without  any connections established

  fast/less reliable than TCP

  ex. real time streaming or Voice over IP use UDP

  fewer delays over UDP than TCP

TCP: 
  continuous connections - more reliable, more latency

server - database: 
  establish a connection to start a session 

Transactions: atomic units of work for database to perform 

Relational databases are *transactional*: All changes to data made through units called transactions 
  
  transaction: single/multiple changes 

    changes within data within a database: 
      UPDATE/INSERT/DELETE

    within a transaction multiple changes are executed in an *ordered* sequence that we dictate to transaction 

 operation - success/fails together as a unit 

Relational databases: All work captured in transactions 

Each transaction, work is done with UPDATE/INSERT/DELETE bundled as a whole 

ex

  transaction.add('INSERT INTO...')
  transaction.add('DELETE...')
  
  queue up work in a transaction 
  then *commit* the transaction

  transaction.commit() 

"queue" up the changes (UPDATE/INSERT/DELETE) and "commit" the 

 transaction can be cleared by using a rollback

 transaction.rollback()

Why bundle work into transactions? 
  Database systems can fail 
  Database always in a valid state

Summary:
` Queue up your INSERT/DELETE/UPDATE in a transaction and commit the transaction 

  If error, can rollback the transaction 

ACID Properties 

Review: 
  1. Databases use client-server model over a network 
  2. Postgres uses TCP/IP - a connection-based protocol

  3. Start/End session 

  4. Sessions have transactions that commit work to a database 

Maintain consistency in a database before/after a transaction, ACID properties followed 

A: Atomicity: Entire transaction takes place or not at all 

C: Consistency: Database must be consistent before / after a transaction 

I: Isolation: Multiple Transactions occur independently without interference 

D: Durability: Changes of a successful transaction occurs even if system failure occurs 

***Transactions: concern changing data in databaase INSERT/DELETE/UPDATE, not querying (no SELECT etc).

Changes are queued into the transaction and then commit the transaction 

Can rollback a transaction - cleared of commands

Rollback; clear the queue of operations added to a transacton 

Postgres: open source, general purpose, object-relational database management system 

  Object-relational support: includes support for arrays, inheritance

  highly scalable

  transaction-based

  multi-version concurrency control: avoids unnecessary locking when multiple writes are happening to the database at once - avoids wait times for access to database 

    several databases available for reading from and writing to at once 

  great performance / indexing capabilities for optimizing query performance 

 Postgres Terminal Commands 

login: sudo -u postgres -i 

start a server: pg_ctl -D /usr/local/var/postgres start

create a database: createdb <name>
delete a database: dropdb <name> 

psql: interact with a Postgres database 
  interactive terminal app 

  begin a connected session with that database

    psql <dbname>

   
psql commands 
  
  list databases: \l 

  quit: \q

  create a table within a database: create table <name>

  example: 

    create table table1(
      id INTEGER PRIMARY KEY
      description VARCHAR NOT NULL,
  );  

  see tables \dt

  see table schema for table: \d table1

  connect to a diffrent database \c <db name>

relation and table same thing 

  example of using psql 

    start connection to database 'example': psql example
    insert a row: INSERT INTO table1 (id, description) VALUES(1, 'this is a thing'); 
    query a row: SELECT * from table1; 
    query a row with a filter: SELECT * from table1 WHERE id = 1;  

psql: Postgres client to interact with Postgres database 

pgAdmin: GUI Postgres client to interact with PostgresSQL 

PopSQL: GUI Postgres client 

Postgres Adapters: psycopg2 = to make client Python apps 

DBAPISs:
  Provides a standard interface for one programming language to talk to relational database server 

  low level library for writing SQL statements that connevct to a database 

  also known as database adapters 

different DBAPIs for every server framework or language + database system 

  To connect Ruby on Rails app to Postgres server, user ruby-pg 

  To connect node application to Postgres sever, use node-postgres

  To connect Django/Flask application to a Postgres server: psycopg2

psycopg2 commands

    conn = psycopg2.connect(...) : Establish a connection, starting a session, begins a transactoin 

    cursor = conn.curosr() : set a cursor to begin executing commands 

    cursor.execute(<sql command string>)
  
    cursor.commit() : commit the transaction 

    cursor.rollback() : rollback the transaction 

 Steps to get a database-backed web application up and running

  1. create a database using createdb in Postgres

  2. establish a donncection to the database
      use psycopg2.connect()

  3. define and create data schema 
      execute CREATE TABLE commands to create tables/define schema (attricutes, data types etc) that define what data gets housed for web app) 

  4. seed database with initial data 

  5. create routes and views

  6. run server 

  7. deploy server to the web 

SQLAlchemy: Python SQL Toolkit - Tool to interact with databases
  Object Relational Mapping: maps tables and columns to class objects and attributes 

 Example 1:
   in SQL
    CREATE TABLE todos (
      id INTEGER PRIMARY KEY,
      description VARCHAR NOT NULL,
      completed BOOLEAN NOT NULL DEFAULT false

    ); 

  in SQLAlchemy ORM 
    class Todo(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      description = db.Column(db.String(), nullable=False)
      completed = db.Column(db.Boolean, nullable=False, default=False)

 
  Example 2: 
    SELECT * from todos

    Todo.query.all()
    
    Gets executed no mater which database system 

    Each database system may make you write SQL in a slightly different way. 

    SQLAlchemy abstracts those differences away. Don't need to write SQL statement directly 

    Can ignore database system. Can switch between SQLLite/Postgres for example 


Benefits of SQLAlchemy:

  function based query construction 

  avoid writing raw SQL

  avoid sending SQL to the database on every call. Offers automatic caching. 

SQLAlchemy's Layers of Abstraction 

  Without SQLAlchemy:

    use a DBAPI like psycopg2 

    establish connection: conn = psycopg2.connect(...
    create a cursor: cur = conn.cursor()
    execute SQL commands: cur.execute('SELECT...') and commit transactions 
    
    *not scalable as complexity grows 

  With SQLAlchemy: 

    Offers multiple layers of abstraction 

    lowest level: offers DBAPI 

    Connection Pool, Dialect

    SQLExpressions / Engines 

    ORM 

  Dialect Docs: https://docs.sqlalchemy.org/en/14/dialects/

    Allows us to forget about the database system we're using 

  Connection Pool: 

    Avoide open/close connections for every data change 

    Handles dropped connections

    Avoid many small calls when making small changes to DB 

  Engine: 
    
    Lowest level layer of abstraction to interact with database 

    Send raw SQL to database 

    Ex 

      engine = create_engine('postgres://...') 

      conn = engine.connect()
      result = conn.execute('SELECT * from vehicles;') 

   SQL Expressions 
      
      compose python objects to compose SQL expressions instead 

      todos = Table('todos', ...)

      ins = todos.insert().values(
              description='Clean my room', 
              completed=False
          )

      s = select([todos])

      conn = engine.connect()
      result = conn.execute(ins)
      result = conn.execute(s)

      result.close()

  SQLAlchemy ORM 
    highest level of abstraction

    compose SQL Expressions by building Python classes of objects which map 
    to tables in the database 

    Maps classes to tables 

    ORM: optional library to interact (write/read) with database 

    SQLAlchemy Core

    SQLAlchemy ORM
      Uses the Core library 

      ORM maps from database schema to Python objects 

      ORM persists objects into corresponding database tables 

  Mapping between Tables and Classes

      class Human:

        def __init__(self, first_name, last_name, age):
          self.first_name = first_name
          self.last_name = last_name
          self.age = age 
      
      sarah = Human('Sarah', 'Silverman', 48) 

      bob = Human('Bob', 'Sage', 54)

      ...

      CREATE TABLE humans (
        id INTEGER PRIMARY KEY, 
        first_name VARCHAR
        last_name VARCHAR
        age INTEGER 

    class is the table

    attributes are the columns 

    instantiate a class is like creating a table 

    create instances (objects) of a class is like creating rows in a table 

    column maps to attribute in class

    table schema maps to class definition 

    rows in a table map to objects that are instances of a class 

    Summary: 

      Tables map to classes 

      Table records(rows) map to class objects 

      Table columns map to class attributes 

Flask 

  simple web framework for serving web pages with data 

  https://flask.palletsprojects.com/en/2.0.x/
  
  https://docs.sqlalchemy.org/en/14/dialects/


