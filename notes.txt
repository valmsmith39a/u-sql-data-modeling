Python3
Flask
PostgreSQL
psycopg2: connect to Postgres server to a Flask application 
SQLAlchemy
Flask-SQLAlchemy

Database Management System
  Software to interact with a database

Database Application Programming Interfaces (DBAPIs)
  Interact with a database from another language/webserver framework

pyscopg2
  library to interact with database from Python

relational databases
  database: collection of data
  database system: storing/retrieving data 

properties of databases
  Persistence: access later 
  Shared source of truth: accessible by many usuers
  Store many data types 
  Concurrency control (handling many db actions at once)

relational vs nonrelational databases 
  
relational database 
  All data is stored in tables
  Every list of columns with data types per column
  Data intergrity: 
    Constraints 
    Triggers

Primary Keys (Composite key for multiple columns of primary keys)
  1 or more columns that uniquely identifies the whole row
  If more than 1 column

Foreign Key
  Maps 2 primary keys: encodes relationship from one table to another 

    Ex vehicles, drivers 
    id of drivers 
    have driver_id in anaother table's columns to link drivers and v    vehicles 

SQL: Structure Query Language
  Standard langage for communicating with a relational database 

  Different "dialects" 

SQL commands 
  Manipulating data
    Insert 
    Update
    Delete

  Querying data
    Select

  Structure data
    Create table
    Alter table
    Drop table

    Add column
    Drop column

Client Server model
  Request/Response 

Server: Postgres
Client: Command line applications/Graphical User Interfaces/Web apps

Database Server -[Web Server - Web Client]

Database - Server - Client 

Client - Server - Database 

Communication protocols used to transfer data over internet 

TCP/IP: Transmission Control Protocol / Internet Protocol 

Client/Server uses a communication protocol 

Postgres follows client-server model and supports TCP/IP for communication 


IP addresses: location of computers on a network 
Ports: describes where to receive traffic at recipient computer 

port 80: HTTP requests 
5432: most database ports - Default port for Postgres

TCP/IP: 
  connection-based protocol
  Open a connection to start communications 
  Close a connection to end communications 

TCP/IP suit of protocols

connections/sessions 

session: marks the start and end of a connection

session: 
start a connection - transactions are committed to the database- end a connection

UDP: User Datagram Protocol
  Hosts on the network send data (datagrams) without  any connections established

  fast/less reliable than TCP

  ex. real time streaming or Voice over IP use UDP

  fewer delays over UDP than TCP

TCP: 
  continuous connections - more reliable, more latency

server - database: 
  establish a connection to start a session 

Transactions: atomic units of work for database to perform 

Relational databases are *transactional*: All changes to data made through units called transactions 
  
  transaction: single/multiple changes 

    changes within data within a database: 
      UPDATE/INSERT/DELETE

    within a transaction multiple changes are executed in an *ordered* sequence that we dictate to transaction 

 operation - success/fails together as a unit 

Relational databases: All work captured in transactions 

Each transaction, work is done with UPDATE/INSERT/DELETE bundled as a whole 

ex

  transaction.add('INSERT INTO...')
  transaction.add('DELETE...')
  
  queue up work in a transaction 
  then *commit* the transaction

  transaction.commit() 

"queue" up the changes (UPDATE/INSERT/DELETE) and "commit" the 

 transaction can be cleared by using a rollback

 transaction.rollback()

Why bundle work into transactions? 
  Database systems can fail 
  Database always in a valid state

Summary:
` Queue up your INSERT/DELETE/UPDATE in a transaction and commit the transaction 

  If error, can rollback the transaction 

ACID Properties 

Review: 
  1. Databases use client-server model over a network 
  2. Postgres uses TCP/IP - a connection-based protocol

  3. Start/End session 

  4. Sessions have transactions that commit work to a database 

Maintain consistency in a database before/after a transaction, ACID properties followed 

A: Atomicity: Entire transaction takes place or not at all 

C: Consistency: Database must be consistent before / after a transaction 

I: Isolation: Multiple Transactions occur independently without interference 

D: Durability: Changes of a successful transaction occurs even if system failure occurs 

***Transactions: concern changing data in databaase INSERT/DELETE/UPDATE, not querying (no SELECT etc).

Changes are queued into the transaction and then commit the transaction 

Can rollback a transaction - cleared of commands

Rollback; clear the queue of operations added to a transacton 

Postgres: open source, general purpose, object-relational database management system 

  Object-relational support: includes support for arrays, inheritance

  highly scalable

  transaction-based

  multi-version concurrency control: avoids unnecessary locking when multiple writes are happening to the database at once - avoids wait times for access to database 

    several databases available for reading from and writing to at once 

  great performance / indexing capabilities for optimizing query performance 

 Postgres Terminal Commands 

login: sudo -u postgres -i 

start a server: pg_ctl -D /usr/local/var/postgres start

create a database: createdb <name>
delete a database: dropdb <name> 

psql: interact with a Postgres database 
  interactive terminal app 

  begin a connected session with that database

    psql <dbname>

   
psql commands 
  
  list databases: \l 

  quit: \q

  create a table within a database: create table <name>

  example: 

    create table table1(
      id INTEGER PRIMARY KEY
      description VARCHAR NOT NULL,
  );  

  see tables \dt

  see table schema for table: \d table1

  connect to a diffrent database \c <db name>

relation and table same thing 

  example of using psql 

    start connection to database 'example': psql example
    insert a row: INSERT INTO table1 (id, description) VALUES(1, 'this is a thing'); 
    query a row: SELECT * from table1; 
    query a row with a filter: SELECT * from table1 WHERE id = 1;  

psql: Postgres client to interact with Postgres database 

pgAdmin: GUI Postgres client to interact with PostgresSQL 

PopSQL: GUI Postgres client 

Postgres Adapters: psycopg2 = to make client Python apps 

DBAPISs:
  Provides a standard interface for one programming language to talk to relational database server 

  low level library for writing SQL statements that connevct to a database 

  also known as database adapters 

different DBAPIs for every server framework or language + database system 

  To connect Ruby on Rails app to Postgres server, user ruby-pg 

  To connect node application to Postgres sever, use node-postgres

  To connect Django/Flask application to a Postgres server: psycopg2

psycopg2 commands

    conn = psycopg2.connect(...) : Establish a connection, starting a session, begins a transactoin 

    cursor = conn.curosr() : set a cursor to begin executing commands 

    cursor.execute(<sql command string>)
  
    cursor.commit() : commit the transaction 

    cursor.rollback() : rollback the transaction 

 Steps to get a database-backed web application up and running

  1. create a database using createdb in Postgres

  2. establish a donncection to the database
      use psycopg2.connect()

  3. define and create data schema 
      execute CREATE TABLE commands to create tables/define schema (attricutes, data types etc) that define what data gets housed for web app) 

  4. seed database with initial data 

  5. create routes and views

  6. run server 

  7. deploy server to the web 

SQLAlchemy: Python SQL Toolkit - Tool to interact with databases
  Object Relational Mapping: maps tables and columns to class objects and attributes 

 Example 1:
   in SQL
    CREATE TABLE todos (
      id INTEGER PRIMARY KEY,
      description VARCHAR NOT NULL,
      completed BOOLEAN NOT NULL DEFAULT false

    ); 

  in SQLAlchemy ORM 
    class Todo(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      description = db.Column(db.String(), nullable=False)
      completed = db.Column(db.Boolean, nullable=False, default=False)

 
  Example 2: 
    SELECT * from todos

    Todo.query.all()
    
    Gets executed no mater which database system 

    Each database system may make you write SQL in a slightly different way. 

    SQLAlchemy abstracts those differences away. Don't need to write SQL statement directly 

    Can ignore database system. Can switch between SQLLite/Postgres for example 


Benefits of SQLAlchemy:

  function based query construction 

  avoid writing raw SQL

  avoid sending SQL to the database on every call. Offers automatic caching. 

SQLAlchemy's Layers of Abstraction 

  Without SQLAlchemy:

    use a DBAPI like psycopg2 

    establish connection: conn = psycopg2.connect(...
    create a cursor: cur = conn.cursor()
    execute SQL commands: cur.execute('SELECT...') and commit transactions 
    
    *not scalable as complexity grows 

  With SQLAlchemy: 

    Offers multiple layers of abstraction 

    lowest level: offers DBAPI 

    Connection Pool, Dialect

    SQLExpressions / Engines 

    ORM 

  Dialect Docs: https://docs.sqlalchemy.org/en/14/dialects/

    Allows us to forget about the database system we're using 

  Connection Pool: 

    Avoide open/close connections for every data change 

    Handles dropped connections

    Avoid many small calls when making small changes to DB 

  Engine: 
    
    Lowest level layer of abstraction to interact with database 

    Send raw SQL to database 

    Ex 

      engine = create_engine('postgres://...') 

      conn = engine.connect()
      result = conn.execute('SELECT * from vehicles;') 

   SQL Expressions 
      
      compose python objects to compose SQL expressions instead 

      todos = Table('todos', ...)

      ins = todos.insert().values(
              description='Clean my room', 
              completed=False
          )

      s = select([todos])

      conn = engine.connect()
      result = conn.execute(ins)
      result = conn.execute(s)

      result.close()

  SQLAlchemy ORM 
    highest level of abstraction

    compose SQL Expressions by building Python classes of objects which map 
    to tables in the database 

    Maps classes to tables 

    ORM: optional library to interact (write/read) with database 

    SQLAlchemy Core

    SQLAlchemy ORM
      Uses the Core library 

      ORM maps from database schema to Python objects 

      ORM persists objects into corresponding database tables 

  Mapping between Tables and Classes

      class Human:

        def __init__(self, first_name, last_name, age):
          self.first_name = first_name
          self.last_name = last_name
          self.age = age 
      
      sarah = Human('Sarah', 'Silverman', 48) 

      bob = Human('Bob', 'Sage', 54)

      ...

      CREATE TABLE humans (
        id INTEGER PRIMARY KEY, 
        first_name VARCHAR
        last_name VARCHAR
        age INTEGER 

    class is the table

    attributes are the columns 

    instantiate a class is like creating a table 

    create instances (objects) of a class is like creating rows in a table 

    column maps to attribute in class

    table schema maps to class definition 

    rows in a table map to objects that are instances of a class 

    Summary: 

      Tables map to classes 

      Table records(rows) map to class objects 

      Table columns map to class attributes 

Flask 

  simple web framework for serving web pages with data 

  https://flask.palletsprojects.com/en/2.0.x/
  
  https://docs.sqlalchemy.org/en/14/dialects/

  127.0.0.1: IP Address (internet protocol address) of local machine - unique address that identifies a device on the internet or local network. 

  localhost: hostname refering to current computer used to access it. localhost resolves to 127.0.0.1
 
 @app.route('/')
 def index(): 
    return 'Hello world'
  
 @app.route: Python decorator 
  Decorators take functions and return another function to extend the input function with additional ("decorated") functionality. 
  @app.route is a decorate that takes an input function index() as a callback that is invoked when a requet to route / comes in from client 
 
  Enable live reload: 
    export FLASK_ENV=development 
    or 
    FLASK_APP=app.py FLASK_DEBUT=true flask run 

  Another way to run flask app:
    if __name_- = '__main__':
      app.run()

    script's __name__ set to __main__ by Python interpretor which runs through executing all code found in the script. When reaches the end and finds if __name__ == 'main__' evaluates to True and calls app.run() 

db = SQLAlchemy(app) # an instance of the SQLAlchemy class from Flask-SQLAlchemy library

db: interface for interacting with database
db.Model: object that lets us create / manipulate data models (class or table) 
db.session: create/maniupulate database transactons (within that session) 

SQLAlchemy models
  
  set tables: db.create_all()

SQLAlchemy: dataytpes
  Integer
  String(size)
  Text
  DateTime
  float
  Boolean
  PickleType
  LargeBinary

  https://flask-sqlalchemy.palletsprojects.com/en/2.x/models/
  
  Ex
    name = db.Column(db.String()) : sets a data type of string with variable length

    VARCHAR: Variable Character: character data that is varying. Indeterminate length string data type.

 
SQLAlchemy constraints
  constraints: ensures data integrity
    data integrity:  
      data is stored accurately
      applying rules consistently 
  Example
    name = db.Column(db.String(), nullable=False)
    nullable=False: same as NOT NULL in SQL: column should never be null 
    unique=True: same as UNIQUE in SQL: each row should have a unique value
    unique=True, nullable=False


Recap:
  SQLAlchemy: layers of abstracton
    DBAPI: Implements a protocol for connecting to a database (ex pyscopg2)
    Connection Pool: Manages a pool of connects  that we reuse 
    Dialect: Translates generic SQL instructions to database-specific instructions for the DPAPI + specific backend (MySQL, Postgres.etc)
    engine: connects to database 
    SQL Expression: Write SQl using Python expressions
    ORM: Write and query Python objects mapped to db tables, generating SQL expressions for you.

  SQLAlchemy ORM: 
    Mapping between Classes and Tables
  
  Flask SQLAlchemy library and SQLAlchemy class 
    db.Model: ability to create and manipulate models (tables/classes)
    db.session: ability to create and manipulate transactions (bundles of SQL statements)
  
  Define a model (class Person) 

  Debugging tricks using dunder repr method __repr__ 

Python Interactive mode:
  python3
  from flask_hello_app import db, Person
  person = Person(name='Sarah')
  db.session.add(person)
  db.session.commit()

  Person.query.all()
  Person.query.filter_by(name='Amy').all()
  results = Person.query.filter_by(name='Amy').all()
  results[0]
  results[0].name 
  
  person1 = Person(name='New Person 1')
  person2 = Person(name='New Person 2')
  db.session.add_all([person1, person2]) 
  db.session.commit()
  
SQLAlchemy ORM in depth

  object relational mapping library 

  object life cycle, sessions, query object 

  Review using SQLAlchemy ORM in Python Interactive mode 

    from hello_flask_app import db, Person
    person = Person(name='Amy')
    db.session.add(person)
    db.session.all_all([person1, person2]) 
    db.session.commit()
    Person.query.first()
    person = Person.query.filter_by(name='Amy').first()
    person.name
    'Amy'

  Model.query
    SQLAlchemy query object
      object exists on a given model that we define in a SQLAlchemy application 
      query: source of all SELECT statements generated by the ORM 
        ability to get filtered slices of data
        Most common query methods on query object
          Person.query.filter_by(name='Amy')
          Person.query.all()
          Person.query.count()
          Person.query.filter(Person.name == 'Amy')
          Person.query.filter(Person.name == 'Amy', Team.name == 'Udacity)
          Person.query.get(1) # gets by primary key

        Bulk operations on data
          Product.query.filter_by(category='Misc').delete()
        
        Model.query method chaining 
          Person.query
            .filter(Person.name == 'Amy')
            .filter(Team.name == 'Udacity')
            .first()
  
          Driver.query
            .join('vehicles')
            .filter_by(driver_id=3)
            .all()
        
        Alternatives
          db.session.query(Person) same as Person.query
          session.query(Person).join(Team)

         Useful commands:
          Select records
            MyModel.query.all()
            MyModel.query.first()
          Filtering
            MyModel.query.filter_by(my_table_attribute='some value')
            MyModel.query.filter(MyOtherModel.some_attr='some value')
            OrderItem.query.filter(Product.id=3)
          Ordering
            MyModel.order_by(MyModel.created_at)
            MyModel.order_by(db.desc(MyModel.created_at)) # db.desc: to order in descending order 
          Limit
            Order.query.limit(100).all()
          Aggregates
            Task.query.filter(completed=True).count()
            MyModel.query.get(model_id) 
          Bulk Deletes
             Task.query.filter_by(category='Archived').delete()
          Joined Queries
            Driver.query.join('vehiciles')
          
          Query API: https://docs.sqlalchemy.org/en/14/orm/query.html   
          Person.query.first()
          Person.query.filter(MyOtherModel.some_attr='some value')
          MyModel.order_by(MyModel.created_at)
          MyModel.order_by(db.desc(MyModel.created_at))

            Ex OrderItem.query.filter(product.id=3)


